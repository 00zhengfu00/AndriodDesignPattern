<resources>
    <string name="app_name">AndriodDesignPattern</string>

    <string name="all_order_tab1">工厂方法模式</string>
    <string name="all_order_tab2">单利模式</string>
    <string name="all_order_tab3">建造者模式</string>
    <string name="all_order_tab4">原型模式</string>
    <string name="all_order_tab5">适配器模式</string>
    <string name="all_order_tab6">问题单</string>
    <string name="all_order_tab7">过期/取消</string>
    <string name="all_order_tab8">待执行</string>
    <string name="all_order_tab9">待完成</string>
    <string name="singletondes">代码中一共写了6总方式：饿汉式，懒汉式，双重锁，内部类实现单利，枚举实现单利，</string>
    <string name="factory">在实际开发过程中我们都习惯于直接使用 new 关键字用来创建一个对象，可是有时候对象的创造需要一系列的步骤：你可能需要计算或取得对象的初始设置；选择生成哪个子对象实例；或在生成你需要的对象之前必须先生成一些辅助功能的对象，这个时候就需要了解该对象创建的细节，也就是说使用的地方与该对象的实现耦合在了一起，不利于扩展，为了解决这个问题就需要用到我们的工厂方法模式，它适合那些创建复杂的对象的场景，工厂方法模式也是一个使用频率很高的设计模式。</string>
    <string name="singleton">一、作用 单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点 二、适用场景 1. 应用中某个实例对象需要频繁的被访问。 2. 应用中每次启动只会存在一个实例。如账号系统，数据库系统。</string>
    <string name="builder">产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。 抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。 建造者：实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。 导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。</string>
    <string name="prototype">原型模式：使用的场景，当对象构造的方法非常的复杂，在生成对象非常好性能，我们就需要原型模式，通过复制克隆一个指定对象来创建更多同类型的对象</string>
    <string name="creatormodel">创建者模式</string>
    <string name="structuralmodel">结构型模式</string>
    <string name="adaptermodel">适配器模式：手机电源的适配器，笔记本电脑的充电器，你如果要给笔记本充电，你肯定不会带个充电宝吧，特别好理解,将一个类的接口转换成客服希望的另外的一个接口，adapter模式使得原来由于接口不兼容而不能一起工作的那些类可以一起工作</string>
    <string name="all_order_tab10">装饰者模式</string>
    <string name="decorator">装饰者模式：装饰者模式：动态的为一个对象增加新的功能
 装饰者模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的
 新功能，使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀
 动态的给一个对象添加额外的职责或者行为，就新增功能来说，Decorator 模式相比生成子类更加的灵活</string>
</resources>
