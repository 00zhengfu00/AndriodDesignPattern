<resources>
    <string name="app_name">AndriodDesignPattern</string>

    <string name="all_order_tab1">工厂方法模式</string>
    <string name="all_order_tab2">单利模式</string>
    <string name="all_order_tab3">建造者模式</string>
    <string name="all_order_tab4">原型模式</string>
    <string name="all_order_tab5">适配器模式</string>
    <string name="all_order_tab6">问题单</string>
    <string name="all_order_tab7">过期/取消</string>
    <string name="all_order_tab8">待执行</string>
    <string name="all_order_tab9">待完成</string>
    <string name="singletondes">代码中一共写了6总方式：饿汉式，懒汉式，双重锁，内部类实现单利，枚举实现单利，</string>
    <string name="factory">在实际开发过程中我们都习惯于直接使用 new 关键字用来创建一个对象，可是有时候对象的创造需要一系列的步骤：你可能需要计算或取得对象的初始设置；选择生成哪个子对象实例；或在生成你需要的对象之前必须先生成一些辅助功能的对象，这个时候就需要了解该对象创建的细节，也就是说使用的地方与该对象的实现耦合在了一起，不利于扩展，为了解决这个问题就需要用到我们的工厂方法模式，它适合那些创建复杂的对象的场景，工厂方法模式也是一个使用频率很高的设计模式。</string>
    <string name="singleton">一、作用 单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点 二、适用场景 1. 应用中某个实例对象需要频繁的被访问。 2. 应用中每次启动只会存在一个实例。如账号系统，数据库系统。</string>
    <string name="builder">产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。 抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。 建造者：实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。 导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。</string>
    <string name="prototype">原型模式：使用的场景，当对象构造的方法非常的复杂，在生成对象非常好性能，我们就需要原型模式，通过复制克隆一个指定对象来创建更多同类型的对象</string>
    <string name="creatormodel">创建者模式</string>
    <string name="structuralmodel">结构型模式</string>
    <string name="adaptermodel">适配器模式：手机电源的适配器，笔记本电脑的充电器，你如果要给笔记本充电，你肯定不会带个充电宝吧，特别好理解,将一个类的接口转换成客服希望的另外的一个接口，adapter模式使得原来由于接口不兼容而不能一起工作的那些类可以一起工作</string>
    <string name="all_order_tab10">装饰者模式</string>
    <string name="decorator">装饰者模式：装饰者模式：动态的为一个对象增加新的功能
 装饰者模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的
 新功能，使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀
 动态的给一个对象添加额外的职责或者行为，就新增功能来说，Decorator 模式相比生成子类更加的灵活</string>
    <string name="all_order_tab11">代理模式</string>
    <string name="proxymodel">代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。</string>
    <string name="all_order_tab12">外观模式</string>
    <string name="facade">外观模式：开发中比如图片的加载框架，封装到最后只暴露
    一个出来最上级的类共外部使用,使用者根本不用关心这个类具体调用了什么，用的什么逻辑都不用
        关心。但是不符合开闭原则
    </string>
    <string name="all_order_tab13">桥接模式</string>
    <string name="bridge">桥接模式：使用的模式，在某些类型由于自身的逻辑，它具有两个或者是多个维度的变化，怎么应对这种多维度的变化
        如何的合理利用面向对象的技术使得改类型能够轻松的沿着多个方向进行变化，而不引入额外的复杂度
        这就是桥接模式出现的原理（Bridge模式）
    </string>
    <string name="all_order_tab14">组合模式</string>
    <string name="composite">输出结果\n
         北京总公司\n
         --总公司人力资源部\n
         --总公司财务部\n
       --山东分公司\n
        ----山东分公司人力资源部\n
        ----山东分公司账务部\n
       ----济南办事处\n
        ------济南办事处财务部\n
       ------济南办事处人力资源部\n
       ----枣庄办事处\n
        ------枣庄办事处财务部\n
        ------枣庄办事处人力资源部\n
         --上海华东分公司\n
         ----上海华东分公司人力资源部\n
        ----上海华东分公司账务部\n
        ----杭州办事处\n
       ------杭州办事处财务部\n
       ------杭州办事处人力资源部\n
        ----南京办事处\n
         ------南京办事处财务部\n
        ------南京办事处人力资源部</string>
    <string name="compositedes">组合模式：我虽然敲了两个例子，但是我自己理解起来，感觉有点小问题
    ，因为在实际的工作中，我们真正的用到这种模式特别少，所以如果需要理解这种的模式还要自己多敲代码和例子
        下面是一个公司例子的输出结果，可以看看
    </string>
    <string name="all_order_tab15">享元模式</string>
    <string name="flyweight">享元模式：
    下面的是个享元模式实现的例子：加入我们12306的购票的系统，如果每个人买张车票都需要在后台给它new个车票的实体类的话，
        全中国的人民那么都去买，是不是服务器必然挂掉，每次查询一个火车票的结果，那么必然会真加大量的创建的对象，销毁，使得
        GC任务繁重，那么这时候就需要使用享元模式了
    </string>
    <string name="behavioralmdel">行为型模式</string>
    <string name="all_order_tab16">策略模式</string>
    <string name="strtategy">在安卓中，listview就是实现的策略的模式
 * listView.setAdapter(ListAdapter) 当实现复杂的条目 设置的是BaseAdapter 或者是ArrayAdapter 是listAdapter
 * 的子类，通过对比发现listAdapter就是策略strategy接口，arrayadapter就是具体的实现的子类</string>
    <string name="all_order_tab17">模板方法模式</string>
    <string name="templatemodel">
        模板模式:定义一个算法中的操作框架，而将一些步骤延迟到子类中，使得子类可以不改变算法额结构即可定义该
 * 算法的某些的特定的步骤.\n
        使用的场景：
 \n 1、多个子类有公有的方法，并且逻辑基本相同
 \n 2、重要复杂的算法，可以把核心算法设计模板方法，周边的相关细节功能则由各个子类实现
 \n 3、重构时候，模板方法是一个经常使用的方法，把相同的代码抽取到父类中，然后通过构造函数去约束其行为
    \n 在安卓中 view的Draw方法就空实现，自定义view要是子类需要的话就重写 ondraw方法，erondraw的方法在父类View
        中已经帮我们调用的顺序做好了，然后我们只需要关心你到底怎么去实现 就是ondraw方法里面
    </string>
    <string name="all_order_tab18">观察者模式</string>
    <string name="observer">安卓的源码中很多也使用了观察者模式，比如onclickListener contentObserver Observable  * 组件通信RXjava和 Rxandroid EventBus 最常用的还是Adapter中的notifyDataSetChanged（）方法  * 可以通过BaseAdapter的源码分析。当listview的数据发生了变化时候，我们调用adapter的notifyDataSetChanged（）  * 的方法，这个方法又会调用观察者AdapterDataSetObserver的onchanged的方法，onchanged的方法  * 又会调用requestLayout（）的方法来重新布局，这就是观察者很好的例子</string>
    <string name="all_order_tab19">迭代子模式</string>
    <string name="iterator">我理解的迭代子模式： \n
         迭代子模式简化了聚集的接口，迭代具备了一个变量的接口，这样的聚集的接口就不需要具备遍历接口了 \n
         每一个聚集对象都可以有一个或者是多个迭代子的对象，每一个迭代子的迭代状态可以是彼此独立的，因此，一个迭代对象可以同时  \n
        有几个迭代进行中，由于遍历算法被封装在迭代子的角色里面，因此迭代的算法可以独立于聚集的角色变换  \n 缺点：  \n 如果用静态迭代子，时间和内存是个问题，如果项目过大，迭代子复杂，静态的迭代子不是用  \n如果是动态迭代子的，可以在时间和性能上有很好的提升，但是一般人，比如像我，能力不够，驾驭不了，特别在多线程中使用中  * 更加麻烦，所以用到了还需要好好研究</string>
    <string name="all_order_tab20">责任链模式</string>
    <string name="chainofresponsibility">
        何为责任链：说白了就是一个事件的传递的链条，一般这个链条上有很多的事件消费者，每个事件的消费者都有机会接受
  并消费事件，假如第一个对象可以处理，则处理，后续的就不能处理，不能处理，就传递到下一个
  在安卓中，常见的责任链模式就是touch事件的传递\n
  责任链的优点：\n
1、降低耦合度：该模式使得一个对象无需知道是哪一个对象处理请求的，对象仅需知道该请求
 会被正常的处理，接受者和发送者都没有对方的明确的信息，其链中的对象不需要链的结构
 \n 2、职责链可简化对象的互相的链接，他们仅仅需要保持一个指向的引用，而不需要保持它所有的后选择的引用
  ，简单一点就是这个链只需要知道下个链是那个就行了，而且这个链的是有顺序的哦
 \n3、增强了给对象指派职责的灵活性;当对象中分派职责，职责链给你更多的灵活性。你可以通过在运行时刻对该链条
  进行动态的增加或者是修改来改变一个请求的那些职责
 \n 4、增加新的请求处理类很方便

 \n缺点：
 \n 1、不能保证请求一定被接受，一个请求没有明确的接受者，那么就不能保证它一定会被处理，该请求可能一直到链的
  末端都得不到处理
 \n2、代码调试不方便

 \n关于纯与不纯的责任链模式
 \n 一个具体处理者角色处理只能对请求作出两种行为中的一个：一个是自己处理（承担责任），另一个是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又将责任向下传的情况。
  请求在责任链中必须被处理，不能出现无果而终的结局。
 \n 不纯的职责链模式
  在一个纯的职责链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的职责链模式里面，一个请求可以最终不被任何接收端对象所接收。
    </string>
    <string name="all_order_tab21">命令模式</string>
    <string name="commandPatternModel">
        命令模式：将一个请求封装成为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或者是记录请求日志以及支持可撤销的操作\n
 使用的场景：\n
 \n 1、系统需要将请求调用者和请求接受者解耦，使得调用者和接受者不直接的交互
 \n 2、系统需要在不同的时间指定请求，将请求队列（线程池+工作队列）去执行请求
 \n 3、系统需要支持命令的撤销（undo）和redo操作，比如系统挂掉之后重启做一些恢复的操作，还有数据库的事务等，命令模式其实就是对命令进行封装，将命令请求者和命令执行者的责任分离开来实现松耦合
 \n 总结：
 \n 1、每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接受的一方收到请求，并执行操作
 \n 2、命令模式允许请求的一方和接受的一方独立开来，使得请求的一方不必知道接收请求一方的接口，更不知道请求是怎么样被接收的，以及操作是否被执行合适被执行，以及怎么样被执行
 \n 3、命令模式是请求本身成为一个对象，这个对象和其他对象一样可以被储存和传递，只有实现了抽象命令接口的具体命令才能与接受者相关联</string>
</resources>
